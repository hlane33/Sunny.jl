using Sunny, FFTW

"""
G should have dimensions (N_sites, N_times) where N_times matches the 
expected trajectory length in samplebuf.

Like add_sample() in Sunny/CorrelationSampling but uses the quantum new sample
I imagine there is a way to merge quantum_new_sample with new_sample in the Sunny SRC code such that this function 
is redundant, but I didn't want to mess with it for now.
"""
function quantum_add_sample!(sc::SampledCorrelations, G::Array{ComplexF64,2}; window=:cosine)
    # Step 1: Replace new_sample! with quantum data injection
    quantum_new_sample!(sc, G)
    
    # Step 2: Use Sunny's existing accum_sample! 
    Sunny.accum_sample!(sc; window)
    
    println("Quantum TDVP data processed through Sunny's infrastructure")
end

"""
Replace new_sample! to inject quantum correlation data instead of classical trajectory
G already contains the correlations that are generated by trajectories in Sunny/CorrelationSampling.jl
"""
function quantum_new_sample!(sc::SampledCorrelations, G::Array{ComplexF64,2})
    N_sites, N_times = size(G)
    buf_size = size(sc.samplebuf, 6)
    nsnaps = (buf_sizeÃ·2) + 1
    
    # Clear buffer
    sc.samplebuf .= 0.0
    

    # Inject quantum correlation data
    # This assumes you want to put G[site, time] into the observable buffer
    for site in 1:N_sites
        for t in 1:N_times
            # Put quantum correlation G[site, t] into samplebuf
            # You may need to adjust indices based on your specific setup
            sc.samplebuf[1, 1, 1, 1, site, t] = G[site, t]
        end
    end
    
    # Zero-pad the rest (matching original new_sample! behavior)
    sc.samplebuf[:,:,:,:,:,(nsnaps+1):end] .= 0
    
    println("Quantum correlation data injected into samplebuf")
end

function get_quantum_correlations(N_sites::Int, energies, sys; dt)
    # Create minimal 1D system -- since we have already calculated correlations
    # this just ensures that dimensions of G match dimensions of samplebuffer
    latvecs =  [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions = [[0.0, 0.0, 0.0]]
    cryst = Crystal(latvecs, positions)
    sys = System(cryst, [1 => Moment(s=1, g=2)], :dipole)
    
    # Create SampledCorrelations with matching parameters
    # dt is redundant here as correlations have already been calculated but must abide by what 
    #sampled correlations is expecting
    positions = zeros(Vec3, 1, 1, 1, N_sites)
    sc = SampledCorrelations(sys; 
                           measure=ssf_trace(sys),
                           energies=energies, 
                           positions = positions,
                           dt=dt, 
                           calculate_errors=false)
    
    return sc
end

"""
Complete workflow to process TDVP data through Sunny's infrastructure
"""
function Get_StructureFactor_with_Sunny(G::Array{ComplexF64,2}, energies, sys; window=:cosine)
    
    # Create compatible SampledCorrelations object
    N_sites = size(G,1)
    sc = get_quantum_correlations(N_sites,energies, sys; dt = 0.5)
    
    # Inject quantum data and process
    quantum_add_sample!(sc, G; window)
    
    println("TDVP data successfully processed through Sunny")
    println("Sample count: $(sc.nsamples)")
    println("Energy range: $(energies[1]) to $(energies[end])")
    
    return sc
end

