using Sunny, FFTW

"""
G should have dimensions (N_sites, N_times) where N_times matches the 
expected trajectory length in samplebuf.

Like add_sample() in Sunny/CorrelationSampling but uses the quantum new sample
I imagine there is a way to merge quantum_new_sample with new_sample in the Sunny SRC code such that this function 
is redundant, but I didn't want to mess with it for now.
"""
function quantum_add_sample!(sc::SampledCorrelations, G::Array{ComplexF64,2},sys::System,η::Float64,ts; window=:cosine)
    # Step 1: Replace new_sample! with quantum data injection
    quantum_new_sample!(sc, G,sys,η,ts)
    
    # Step 2: Use Sunny's existing accum_sample! 
    Sunny.accum_sample!(sc; window)
    
    println("Quantum TDVP data processed through Sunny's infrastructure")
end

"""
Replace new_sample! to inject quantum correlation data instead of classical trajectory
G already contains the correlations that are generated by trajectories in Sunny/CorrelationSampling.jl
"""
function quantum_new_sample!(sc::SampledCorrelations, G::Array{ComplexF64,2},sys::System, η::Float64,ts)
    
     # Extract system properties
    crystal = sys.crystal
    sys_dims = sys.dims
    natoms = length(crystal.positions)

    buf_size = size(sc.samplebuf, 6)
    nsnaps = (buf_size÷2) + 1
    
    # Clear buffer
    sc.samplebuf .= 0.0
    

    # Inject quantum correlation data
    # This assumes you want to put G[site, time] into the observable buffer

    nsites, ntimes = size(G)
    ncorrs = 6  # Number of correlation pairs in ssf_custom
    
    # Reshape G to spatial structure: (Lx, Ly, Lz, natoms, ntimes)
    G_spatial = reshape(G, sys_dims..., natoms, ntimes)
    
    # Apply exponential damping window
    window = exp.(-η .* ts)
    dt = ts[2] - ts[1]
    
    # Initialize samplebuf: (M=1, ncorrs=6, natoms, natoms, Lx, Ly, Lz)
    samplebuf = zeros(ComplexF64, 1, ncorrs, natoms, natoms, sys_dims...)
    
    # Fill correlation data
    # Since your G represents Sz correlations from TDVP, we map it to the (3,3) correlation pair
    for i in 1:sys_dims[1], j in 1:sys_dims[2], k in 1:sys_dims[3]
        for α in 1:natoms, β in 1:natoms
            
            if α == β
                # Diagonal correlations - use your G data for Sz-Sz (pair index 1 corresponds to (3,3))
                # Take time-integrated (static) value
                sz_sz_correlation = sum(G_spatial[i, j, k, α, :] .* window) * dt
                samplebuf[1, 1, α, β, i, j, k] = sz_sz_correlation  # (3,3) -> index 1
                
                # For other diagonal correlations, set to zero or estimate if you have the data
                # You could potentially estimate Sx-Sx and Sy-Sy from Sz-Sz using spin algebra
                samplebuf[1, 4, α, β, i, j, k] = 0.0  # Sy-Sy (2,2) -> index 4  
                samplebuf[1, 6, α, β, i, j, k] = 0.0  # Sx-Sx (1,1) -> index 6
                
                # Off-diagonal auto-correlations (imaginary parts typically)
                samplebuf[1, 2, α, β, i, j, k] = 0.0  # Sy-Sz (2,3) -> index 2
                samplebuf[1, 3, α, β, i, j, k] = 0.0  # Sx-Sz (1,3) -> index 3
                samplebuf[1, 5, α, β, i, j, k] = 0.0  # Sx-Sy (1,2) -> index 5
            else
                # Off-diagonal (inter-site) correlations
                # If your G contains cross-correlations, extract them here
                # For now, set to zero as placeholder
                for corr_idx in 1:ncorrs
                    samplebuf[1, corr_idx, α, β, i, j, k] = 0.0
                end
            end
        end
    end
    
    
    # Zero-pad the rest (matching original new_sample! behavior)
    sc.samplebuf[:,:,:,:,:,(nsnaps+1):end] .= 0
    
    println("Quantum correlation data injected into samplebuf")
end

function get_quantum_correlations(N_sites::Int, energies, sys; dt)
    # Create minimal 1D system -- since we have already calculated correlations
    # this just ensures that dimensions of G match dimensions of samplebuffer
    
    
    # Create SampledCorrelations with matching parameters
    # dt is redundant here as correlations have already been calculated but must abide by what 
    #sampled correlations is expecting
    positions = nothing
    sc = SampledCorrelations(sys; 
                           measure = ssf_custom((q, ssf) -> real(ssf[3, 3]), sys;apply_g=false),
                           energies=energies, 
                           positions = positions,
                           dt=dt, 
                           calculate_errors=false)

    print("Size of buffer", size(sc.samplebuf))
    
    return sc
end

"""
Complete workflow to process TDVP data through Sunny's infrastructure
"""
function Get_StructureFactor_with_Sunny(G::Array{ComplexF64,2}, energies, sys, η, ts; window=:cosine)
    
    # Create compatible SampledCorrelations object
    N_sites = size(G,1)
    sc = get_quantum_correlations(N_sites,energies, sys; dt = 0.5)


    
    # Inject quantum data and process
    quantum_add_sample!(sc, G, sys,η,ts; window)
    
    println("TDVP data successfully processed through Sunny")
    println("Sample count: $(sc.nsamples)")
    println("Energy range: $(energies[1]) to $(energies[end])")
    
    return sc
end

