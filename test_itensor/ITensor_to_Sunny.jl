using Sunny, FFTW

"""
G should have dimensions (N_sites, N_times) where N_times matches the 
expected trajectory length in samplebuf.

Like add_sample() in Sunny/CorrelationSampling but uses the quantum new sample
I imagine there is a way to merge quantum_new_sample with new_sample in the Sunny SRC code such that this function 
is redundant, but I didn't want to mess with it for now.
"""
function quantum_add_sample!(sc::SampledCorrelations, G::Array{ComplexF64,2},sys::System,η::Float64,ts; window=:cosine)
    # Step 1: Replace new_sample! with quantum data injection
    quantum_new_sample!(sc, G,sys,η,ts)
    
    # Step 2: Use Sunny's existing accum_sample! 
    Sunny.accum_sample!(sc; window)
    
    println("Quantum TDVP data processed through Sunny's infrastructure")
end

"""
Replace new_sample! to inject quantum correlation data instead of classical trajectory
G already contains the correlations that are generated by trajectories in Sunny/CorrelationSampling.jl
"""
function quantum_new_sample!(sc::SampledCorrelations, G::Array{ComplexF64,2}, sys::System, η::Float64, ts)
    buf_size = size(sc.samplebuf, 6)
    print("BUF_SIZE:", buf_size)
    nsnaps = (buf_size÷2) + 1
    
    # Clear buffer
    sc.samplebuf .= 0.0
    
    
    
    
    nsites, ntimes = size(G)
    print("NTIMES", ntimes)
    sys_dims = sys.dims
    natoms = length(sys.crystal.positions)
    
    # Map your linear site index to (i,j,k,atom) coordinates
    for site_linear in 1:min(nsites, prod(sys_dims) * natoms)
        # Convert linear index to spatial coordinates
        # This mapping depends on your specific indexing scheme
        atom = ((site_linear - 1) % natoms) + 1
        spatial_idx = (site_linear - 1) ÷ natoms + 1
        
        # Convert spatial_idx to (i,j,k) - this is system-specific
        k = ((spatial_idx - 1) ÷ (sys_dims[1] * sys_dims[2])) + 1
        j = (((spatial_idx - 1) % (sys_dims[1] * sys_dims[2])) ÷ sys_dims[1]) + 1
        i = ((spatial_idx - 1) % sys_dims[1]) + 1
        
        # Bounds checking
        if i <= sys_dims[1] && j <= sys_dims[2] && k <= sys_dims[3] && atom <= natoms
            for t in 1:min(ntimes, nsnaps)
                # Put G into Sz observable slot (assuming obs index 3 is Sz)
                sc.samplebuf[3, i, j, k, atom, t] = G[site_linear, t]
            end
        end
    end
    
    # Zero-pad remaining times
    sc.samplebuf[:,:,:,:,:,(nsnaps+1):end] .= 0
end



function get_quantum_correlations(N_sites::Int, energies, sys; dt)
    # Create minimal 1D system -- since we have already calculated correlations
    # this just ensures that dimensions of G match dimensions of samplebuffer
    
    
    # Create SampledCorrelations with matching parameters
    # dt is redundant here as correlations have already been calculated but must abide by what 
    #sampled correlations is expecting
    sc = SampledCorrelations(sys; 
                           measure = ssf_custom((q, ssf) -> real(ssf[3, 3]), sys;apply_g=false),
                           energies=energies, 
                           dt=dt, 
                           calculate_errors=false)

    print("measure",measure)
    
    return sc
end

"""
Complete workflow to process TDVP data through Sunny's infrastructure
"""
function Get_StructureFactor_with_Sunny(G::Array{ComplexF64,2}, energies, sys, η, ts; window=:cosine)
    
    # Create compatible SampledCorrelations object
    N_sites = size(G,1)
    sc = get_quantum_correlations(N_sites,energies, sys; dt = 0.5)


    
    # Inject quantum data and process
    quantum_add_sample!(sc, G, sys,η,ts; window)
    
    println("TDVP data successfully processed through Sunny")
    println("Sample count: $(sc.nsamples)")
    println("Energy range: $(energies[1]) to $(energies[end])")
    
    return sc
end

